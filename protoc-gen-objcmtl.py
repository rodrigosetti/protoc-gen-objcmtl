#! /usr/bin/env python3
import sys
import os
from textwrap import dedent

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf import descriptor_pb2 as descriptor

def printe(s):
    print(s, file=sys.stderr)

def parse_parameters(parameter):
    return dict( tuple(x.strip() for x in p.split("=")) for p in parameter.split(",") )

def generate_code(request, response):
    parameters = parse_parameters(request.parameter) if request.parameter else {}
    prefix = parameters.get("prefix", "")

    for proto_file in request.proto_file:
        # TODO: Capitalize file name
        filename, _ = os.path.splitext(os.path.basename(proto_file.name))
        filename = prefix + filename.capitalize()
        file_dir = os.path.dirname(proto_file.name)

        interface_file_name = os.path.join(file_dir, filename) + ".h"
        impl_file_name = os.path.join(file_dir, filename) + ".m"

        # Interface file contents
        iface_file_contents = dedent("""\
        // Generated by the protoc-gen-objcmtl plugin.
        // source: {source}
        #import <Mantle/Mantle.h>

        """.format(source=proto_file.name))

        impl_file_contents = dedent("""\
        // Generated by the protoc-gen-objcmtl plugin.
        // source: {source}
        #import "{iface_file}"

        """.format(source=proto_file.name, iface_file=interface_file_name))

        # flatten the nested messages and enums
        message_types = []
        enum_types = list(proto_file.enum_type)

        msg_queue = list(proto_file.message_type)
        while msg_queue:
            # process next
            message_type = msg_queue.pop()
            # add message to flatten list (processed)
            message_types.append( message_type )

            # add nested msgs to queue for processing
            msg_queue.extend( message_type.nested_type )

            # add enums to flatten list
            enum_types.extend( message_type.enum_type )

        # render enums
        for enum_type in enum_types:
            enum_name = enum_type.name

            iface_file_contents += "typedef enum : NSUInteger {\n"
            iface_file_contents += \
                ",\n".join("   {prefix}_{name} = {number}".format(prefix=enum_name,
                                                                  name=value.name,
                                                                  number=value.number)
                           for value in enum_type.value)
            iface_file_contents += "\n}} {prefix}{name};\n\n".format(prefix=prefix, name=enum_name)

        # render messages
        for message_type in message_types:
            # TODO
            pass

        response.file.add(name=interface_file_name, content=iface_file_contents)
        response.file.add(name=impl_file_name, content=impl_file_contents)

if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.buffer.read()
    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)
