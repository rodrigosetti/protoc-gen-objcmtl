#! /usr/bin/env python3
import sys
import os
from textwrap import dedent

from google.protobuf.compiler import plugin_pb2 as plugin
from google.protobuf import descriptor_pb2 as descriptor

NUMBER_TYPES = { descriptor.FieldDescriptorProto.TYPE_DOUBLE,
                 descriptor.FieldDescriptorProto.TYPE_FLOAT,
                 descriptor.FieldDescriptorProto.TYPE_INT64,
                 descriptor.FieldDescriptorProto.TYPE_UINT64,
                 descriptor.FieldDescriptorProto.TYPE_INT32,
                 descriptor.FieldDescriptorProto.TYPE_FIXED64,
                 descriptor.FieldDescriptorProto.TYPE_FIXED32,
                 descriptor.FieldDescriptorProto.TYPE_UINT32,
                 descriptor.FieldDescriptorProto.TYPE_SFIXED32,
                 descriptor.FieldDescriptorProto.TYPE_SFIXED64,
                 descriptor.FieldDescriptorProto.TYPE_SINT32,
                 descriptor.FieldDescriptorProto.TYPE_SINT64 }

def parse_parameters(parameter):
    return dict( tuple(x.strip() for x in p.split("=")) for p in parameter.split(",") )

def objc_file_name(proto_filename):
    filename, _ = os.path.splitext(os.path.basename(proto_filename))
    filename = filename.capitalize()
    file_dir = os.path.dirname(proto_filename)

    return os.path.join(file_dir, filename)

def generate_code(request, response):
    parameters = parse_parameters(request.parameter) if request.parameter else {}
    prefix = parameters.get("prefix", "")

    all_enums = {}
    for proto_file in request.proto_file:
        message_types = []
        all_enums.update((e.name, e) for e in proto_file.enum_type)
        msg_queue = list(proto_file.message_type)
        while msg_queue:
            message_type = msg_queue.pop()
            message_types.append( message_type )
            msg_queue.extend( message_type.nested_type )
            all_enums.update((e.name, e) for e in message_type.enum_type)

    for proto_file in request.proto_file:
        base_filename = objc_file_name(proto_file.name)

        iface_file_name = base_filename + ".h"
        impl_file_name = base_filename + ".m"

        # Interface file contents
        iface_file_contents = dedent("""\
        // Generated by the protoc-gen-objcmtl plugin.
        // source: {source}
        #import <Mantle/Mantle.h>
        """.format(source=proto_file.name))

        # list of imports
        for dependency in proto_file.dependency:
            imported = objc_file_name(dependency)
            im_path, im_rest = os.path.split(imported)
            common_prefix = os.path.commonprefix([im_path, iface_file_name])
            if im_path.startswith(common_prefix):
                im_path = im_path[len(common_prefix):]
            iface_file_contents += '#import "%s.h"\n' % os.path.join(im_path, im_rest)


        _, iface_include_name = os.path.split(iface_file_name)

        impl_file_contents = dedent("""\
        // Generated by the protoc-gen-objcmtl plugin.
        // source: {source}
        #import "{iface_file}"

        """.format(source=proto_file.name, iface_file=iface_include_name))

        # flatten the nested messages and enums
        message_types = []
        enum_types = list(proto_file.enum_type)

        msg_queue = list(proto_file.message_type)
        while msg_queue:
            # process next
            message_type = msg_queue.pop()
            # add message to flatten list (processed)
            message_types.append( message_type )

            # add nested msgs to queue for processing
            msg_queue.extend( message_type.nested_type )

            # add enums to flatten dictionary
            enum_types.extend(message_type.enum_type)

        # render enums
        for enum_type in enum_types:
            enum_name = enum_type.name
            iface_file_contents += "typedef enum : NSUInteger {\n"
            iface_file_contents += \
                ",\n".join("   {name} = {number}".format(name=value.name,
                                                         number=value.number)
                           for value in enum_type.value)
            iface_file_contents += "\n}} {prefix}{name};\n\n".format(prefix=prefix, name=enum_name)

        # render class references
        for message_type in message_types:
            iface_file_contents += "@class %s;\n" % (prefix + message_type.name)

        # render messages
        for message_type in message_types:
            class_name = prefix + message_type.name
            iface_file_contents += "\n@interface %s : MTLModel <MTLJSONSerializing>\n" % class_name
            impl_file_contents += "\n@implementation %s\n" % class_name

            for field in message_type.field:
                pointer = field.type in NUMBER_TYPES or field.type in {
                            descriptor.FieldDescriptorProto.TYPE_MESSAGE,
                            descriptor.FieldDescriptorProto.TYPE_BYTES,
                            descriptor.FieldDescriptorProto.TYPE_STRING }

                if field.type in NUMBER_TYPES:
                    type_name = "NSNumber"
                elif field.type == descriptor.FieldDescriptorProto.TYPE_BOOL:
                    type_name = "BOOL"
                elif field.type == descriptor.FieldDescriptorProto.TYPE_STRING:
                    type_name = "NSString"
                elif field.type in { descriptor.FieldDescriptorProto.TYPE_MESSAGE,
                                      descriptor.FieldDescriptorProto.TYPE_ENUM }:
                    type_name = prefix + field.type_name.split('.')[-1]
                else:
                    raise Exception("type not supported: %s" %
                                    descriptor.FieldDescriptorProto.Type.Name(field.type))

                is_array = field.label == descriptor.FieldDescriptorProto.LABEL_REPEATED
                is_enum = field.type == descriptor.FieldDescriptorProto.TYPE_ENUM

                iface_file_contents += \
                    "@property {type_name} {maybe_pointer}{name};\n".format(
                            type_name="NSArray" if is_array else type_name,
                            maybe_pointer="*" if pointer or is_array else "",
                            name=field.name
                        )

                if is_enum:
                    enum = all_enums[field.type_name.split('.')[-1]]
                    impl_file_contents += dedent("""
                    + (NSValueTransformer *){name}JSONTransformer {{
                        return [NSValueTransformer mtl_valueMappingTransformerWithDictionary:@{{
                           {mapping}
                          }}];
                        }}
                    """).format(mapping=",\n       ".join('@"{n}": @({n})'.format(n=v.name) for v in enum.value),
                                name=field.name)

                if is_array:
                    impl_file_contents += dedent("""
                    + (NSValueTransformer *){name}JSONTransformer {{
                        return [MTLJSONAdapter arrayTransformerWithModelClass:[{type_name} class]];
                    }}
                    """).format(name=field.name, type_name=type_name)

            prop_to_jsonkey = dict((f.name, f.json_name or f.name) for f in message_type.field)
            impl_file_contents += "+ (NSDictionary *)JSONKeyPathsByPropertyKey {\n    return @{\n        "
            impl_file_contents += ",\n        ".join('@"%s": @"%s"' % fs for fs in prop_to_jsonkey.items())
            impl_file_contents += "\n      };\n}\n"

            iface_file_contents += "@end\n"
            impl_file_contents += "@end\n"

        response.file.add(name=iface_file_name, content=iface_file_contents)
        response.file.add(name=impl_file_name, content=impl_file_contents)

if __name__ == '__main__':
    # Read request message from stdin
    data = sys.stdin.buffer.read()
    # Parse request
    request = plugin.CodeGeneratorRequest()
    request.ParseFromString(data)

    # Create response
    response = plugin.CodeGeneratorResponse()

    # Generate code
    generate_code(request, response)

    # Serialise response message
    output = response.SerializeToString()

    # Write to stdout
    sys.stdout.buffer.write(output)
